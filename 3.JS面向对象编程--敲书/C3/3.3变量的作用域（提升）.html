<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>3.3 变量的作用域</title>
</head>
<body>
	<p>这是一个至关重要的问题。特别是当我们从别的语言转向JS时，必须要明白一点，即在JS中，变量的定义并不是以代码块为作用域的。而是以函数作为作用域。也就是说，如果变量是在某个函数中定义的，那么他在函数以外的地方是不可见的。而如果该变量是定义在if或者for这样的代码块中的，他在代码块之外是可见的。另外，在JS中，术语“全局变量”指的是定义在所有函数之外的变量（也就是定义在全局代码中的变量），与之相对的是“局部变量”，所指的则是在某个函数中定义的变量。其中，函数内的代码可以像访问自己的局部变量那样访问全局变量。反之则不行。</p>
	<p>下面看一个具体实例，请注意两点：</p>
	<ul>
		<li>函数f()可以访问变量global。</li>
		<li>在函数f()以外，变量local是不存在的。</li>
	</ul>
	<script>
		var global = 1;
		function f(){
			var local = 2;
			global++;
			return global;
		}
		f();
		2
		f();
		3
		local;
		error;
	</script>
	<p>这里还有一点很重要，如果我们声明一个变量是没有使用var语句，该变量就会被默认为全局变量。让我们来看一个具体事例。</p>
	<script>
		function f(){
			local=2;  //全局变量
		}
		local
		VM3764:1 Uncaught ReferenceError: local is not defined
		    at <anonymous>:1:1
		(anonymous) @ VM3764:1
		f()
		local
		2
	</script>

	<h3>最佳实践</h3>
	<ul>
		<li>尽量将全局变量的数量降到最低，以避免命名冲突。因为如果有两个人在同一段脚本的不同函数中使用了相同的全局变量名，就很容易导致不可预测的结果和难以察觉的bug。</li>
		<li>最好总是用var语句来声明变量。</li>
		<li>可以考虑使用“单一var”模式。即，尽在函数体内的第一行使用一个var来定义这个作用域中所有需要的变量。这样一来，我们就能很轻松的找到相关变量的定义，并且在很大程度上避免了不小心污染全局变量的情况。</li>
	</ul>
	
	<h3>变量提升</h3>
	<p>下面，我们再来看一个很有趣的例子，他显示了关于局部和全局作用于的另一个重要问题。</p>
	<script>
		var a=123;
		function f(){
			alert(a);  //undefined
			var a=1;
			alert(a);  //1
		}
		f();
	</script>
	<p>
		您可能会想当然的认为alert第一次显示的是123，第二次显示1.但事实并非如此，第一个实际上显示的是undefined，这是因为函数域始终优先于全局域，所以局部变量a会覆盖掉所有与他同名的全局变量，尽管在alert第一次被调用时，a还没有被正式定义（即该值为undefined），但该变量本身已经存在与本地空间了。这种特殊的现象叫做<b>提升</b>。
	</p>
	<p>也就是说，当JS执行过程进入新的函数时，这个函数内被生命的所有变量都会被移动（或者说被提升）到函数最开始的地方。这个概念很重要，必须牢记。另外还需要注意的是，被提升的只有变量的声明，这意味着，只有函数体内声明的这些变量在该函数执行开始时就存在，而与之相关的赋值操作并不会被提升，他还在其原来的位置上。譬如在前面的例子中，局部变量本身被提升到了函数开始处，但并没有在开始出就被赋值为1.那个例子可以被等价的改写为：</p>
	<script>
		var a=123;
		function f(){
			var a;
			alert(a);
			a=1;
			alert(a);
		}
	</script>
	<p>
		当然，我们也可以采用在最见时间中提到过的单一var模式。在这个例子中，我们可以手动提升变量声明的位置，这样一来代码就不会被JS的提升行为所混淆了。
	</p>
</body>
</html>