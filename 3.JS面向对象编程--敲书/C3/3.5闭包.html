<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>3.5闭包</title>
</head>
<body>
	<h2>3.5.1 作用域链</h2>
	<p>
		如您所知，尽管JS中不存在大括号级的作用域，但他有函数作用域，也就是说，在某函数内定义的所有变量在该函数外是不可见的。但如果该变量是在某代码块中被定义的（如在某个if或for语句中），那它在代码块外是可见的。
	</p>
	<script>
		var a=1;
		function f(){
			var b=1;
			return a;
		}
		f(); //1
		b;//ERROR!
	</script>
	<ul>在这里，变量a是属于全局域的，而变量b的作用域就在函数f()内了。所以：
		<li>在f()内，a和b都是可见的；</li>
		<li>在f()外，a是可见的，b则不可见。</li>
	</ul>

<p>在下面的例子中，如果我们在函数outer()中定义了另一个函数inner()，那么在inner()中可以访问的变量及来自她自身的作用域，也可以来自其“父级”作用域。这就形成了一条作用域链，该链的长度（或深度）则取决于我们的需要。</p>
<script>
	var global = 1;
	function outer(){
		var outer_local = 2;
		function inner(){
			var inner_local = 3;
			return inner_local + outer_local + global;
		}
		return inner();
	}

	outer();   //6
</script>
<p>由以上结果，可以看出inner()真的可以访问所有变量。</p>


	<h2>3.5.2 利用闭包突破作用域链</h2>
	<h3>3.5.2.1 闭包#1</h3>
	<p>
		首先，我们先来看一个函数。这个函数与之前所描述的一样，只不过在F中多了返回N，而在函数N中多了返回变量b，N和b都可以通过作用域链进行访问。
	</p>
	<script>
		var a= "global variable";
		var F = function(){
			var b = "local variable";
			var N = function(){
				var c = "inner local";
				return b;
			};
			return N;
		};

		b  //ERROR！
	</script>
	
	<p>函数F中包含了局部变量b，因此后者在全局空间里时不可见的。</p>
	<p>函数N有自己的私有空间，同时也可以访问f()的空间和全局空间，所以b对他来说是可见的。因为F()是可以在全局变量中被调用的，所以我们可以将它的返回值赋值给另一个全局变量，从而生成一个可以访问F()私有空间的新全局函数。</p>
	<script>
		var inner = F();
		inner();  //local variable
	</script>

	<h3>3.5.2.2 闭包#2</h3>
	<p>
		下面这个例子的最终结果与之前相同，但在实现方法上存在一些细微的不同。在这里F()不再返回函数了，而是直接在函数体内创建一个新的全局函数inner()。  
	</p>
	<script>
		var inner;  //placeholder
		var F = function(){
			var b = "local variable";
			var N = function(){
				return b;
			};
			inner = N;
		};

		F();  //undefined
		inner();  //"local variable"
	</script>

	<h3>3.5.2.3 相关定义与闭包#3</h3>
	<p>
		事实上，每个函数都可以被认为是一个闭包。因为每个函数都在其所在域（即该函数的作用域）中维护了某种私有联系。但在大多时候，该作用域在函数体执行完之后就自行销毁了——除非发生一些有趣的事（比如像上一小节所述的那样），导致作用域被保持。
	</p>
	<p>
		根据目前的讨论，我们可以说，如果一个函数会在其父级函数返回之后留住对父级作用域的链接的话，相关闭包就会被创建起来。但其实每个函数本身就是一个闭包，因为每个函数至少都有访问全局作用域的权限，而全局作用于是不会被破坏的。
	</p>
	<p>
		让我们再来看一个闭包的例子。这次我们使用的是函数参数。该参数与函数的局部变量没什么不同，但他们是隐式创建的（即他们不需要使用var来声明）。我们在这里创建了一个函数，该函数将返回一个子函数，而这个子函数返回的则是其父函数的参数：
	</p>
	<script>
		function F(param){
			var N = function(){
				return param;
			};
			param++;
			return N;
		}
		var inner = F(123);
		inner();  //124
	</script>
	<p>
		请注意，当我们的返回函数被调用时，param++已经执行过依次递增操作了。所以inner()返回的是更新后的值。由此我们可以看出，函数所绑定的是作用域本身，而不是在函数定义时该作用域中的变量或变量当前所返回的值。
	</p>

	<h3>3.5.2.4 循环中的闭包</h3>
	<p>
		接下来，让我们来看看新手们在闭包问题上会犯哪些典型的错误。毕竟由闭包所导致的bug往往很难被发现，因为他们总是表面上看起来一切正常。
	</p>
	<p>
		让我们来看一个三次的循环操作，他在每次迭代中都会创建一个返回当前循环序号的新函数。该新函数会被添加到一个数组中，并最终返回。代码如下：
	</p>
	<script>
		function F(){
			var arr = [];
			for(var i=0;i<3;i++){
				arr[i] = function(){
					return i;
				};
			}
			return arr;
		}

		var arr = F();
		arr[0]();  //3
		arr[1]();  //3
		arr[2]();  //3
	</script>
	<p>
		现在，我们拥有了一个包含三个函数的数组。您可以通过在每个数组元素后面加一堆括号来调用他们。按通常的估计，他们应该会依照循环顺序分别输出0,1,2，下面我们来试试(见上)。
	</p>
	<p>
		显然，这并不是我们想要的结果。究竟是怎么回事呢？<b>原来我们在这里创建了三个闭包，而它们都指向了一个共同的局部变量i。但是，闭包并不会记录它们的值，他们所拥有的只是相关域在创建时的一个连接（即引用）。  在这个例子中，变量i恰巧存在于定义这三个函数域中。对这三个函数中的任何一个而言，当他要去获取某个变量时，他会从其所在的域开始逐级寻找那个距离最近的i值。由于循环结束时i的值为3，所以这三个函数都指向了这一共同值。  </b>
	</p>
	<p>
		为什么结果是3不是2呢？这也是一个值得思考的问题，它能帮助您更好的理解循环，请您自行思考。	
	</p>
	<p>
		那么，应该如何纠正这种行为呢？答案是换一种闭包形式。
	</p>
	<script>
		function F(){
			var arr = [],i;
			for(i=0;i<3;i++){
				arr[i] = (function (x){
					return function (){
						return x;
					};
				})(i);
			}
			return arr;
		}

		var arr = F();
		arr[0]();   //0
		arr[1]();   //1
		arr[2]();   //2
	</script>

	<p>
		在这里，我们不再直接创建一个返回i的函数了，而是将i传递给了另一个即时函数。在该函数中，i就被赋值给了局部变量x，这样一来，每次迭代中的x就会拥有各自不同的值了。
	</p>
	<p>
		或者，沃恩也可以定义一个“正常点的”内部函数（不使用即时函数）来实现相同的功能。要点是在每次迭代操作中，我们要在中间函数内将i的值“本地化”。
	</p>

	<script>
		function F(){

			function binder(x){
				return function(){
					return x;
				};
			}

			var arr = [],i;
			for(i=0;i<3;i++){
				arr[i] = binder(i);
			}

			return arr;
		}

		var arr = F();
		arr[0]();   //0
		arr[1]();   //1
		arr[2]();   //2
	</script>


	<h2>3.5.3 getter与setter</h2>
	<p>
		接下来，让我们再来看两个关于闭包的应用实例。首先是创建getter和setter。假设现在有一个变量，他所表示的是某类特定值，或某特定区间内的值。我们不想将该变量直接暴露给外部。因为那样的话，其他部分的代码就有直接修改它的可能，所以我们需要将它保护在相关函数的内部，然后提供两个额外的函数——一个用于获取变量值，另一个用于给变量重新赋值。并在函数中引入某种验证措施，以便在赋值之前给予变量一定的保护。另外，为简洁起见，我们对该类中的验证部分进行了简化：即这里只处理数字值。
	</p>
	<p>
		我们需要将getter和setter这两种函数放在一个共同的函数中，并在该函数中定义secret变量，这使得两个函数能够共享同一作用域。代码如下：
	</p>
	<script>
		var getValue,setValue;
		(function (){
			var secret = 0;  //局部变量

			getValue = function(){   //全局函数
				return secret;
			};

			setValue = function(v){   //全局函数
				if(typeof v === "number"){
					secret = v;
				}
			};

		})();

		getValue();  //0
		setValue(123);
		getValue();  //123
		setValue(false);
		getValue();  //123

	</script>
	
	<p>
		在这里，所有一切都是通过一个即时函数来实现的，我们在其中定义了全局函数getValue()和setValue()，并以此来确保局部变量secret的不可直接访问性。
	</p>

	<h2>3.5.4 迭代器</h2>
	<p>
		在最后一个关于闭包应用的实例中，我们将向您展示闭包在实现迭代器方面的功能。
	</p>
	<p>
		通常情况下，我们都知道如何用循环来遍历一个简单的数组，但是有时候我们需要面对更复杂的数据结构，他们通常会有着与数组截然不同的序列规则。这时候就需要将一些“谁是下一个”的复杂逻辑封装成易于使用的next()函数，然后，我们只需要简单的调用next()就能实现对于相关的遍历操作了。
	</p>
	<p>
		在下面这个例子中，我们将依次通过简单数组，而不是复杂的数据结构来说明问题。该例子是一个接收数组输入的初始化函数，我们在其中定义了一个私有指针i，该指针会始终指向数组中的下一个元素。
	</p>
	<script>
		function setup(x){
			var i = 0;
			return function(){
				return x[i++];
			};
		}
	</script>
	<p>
		现在，我们只需用一组数据来调用一下setup(),就可创建出我们所需要的next()函数，具体如下：
	</p>
	<script>
		var  next = setup(["a","b","c"]);
	</script>

	<p>
		这是一种既简单又好玩的形式：我们只需重复调用一个函数，就可以不停的获取下一个元素。
	</p>
	<script>
		next(); //a
		next(); //b
		next(); //c

	</script>
</body>
</html>